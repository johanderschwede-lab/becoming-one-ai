original_path: /Users/johanniklasson/Documents/becoming-one-ai/CompassBuilder_Phase2/documents_to_process/SIMPLE_STARTING_POINT.md
archived_at: '2025-08-19T11:18:46.359830'
status: processed
category: documentation
file_hash: c24997be60b0c5c009a991cdd12207dfdd05997746c982aca8e20df74bcaa253
analysis_summary:
  categories:
  - technical
  - ai_agents
  - content_processing
  analysis:
    content: "# \U0001F331 Simple Starting Point\n## Begin with the Simplest Possible\
      \ Implementation\n\n### 1. Start with Single Channel (Telegram)\n\n```python\n\
      # simple_bot.py\nfrom telegram.ext import Application, MessageHandler, filters\n\
      \nclass SimpleBot:\n    def __init__(self, token: str):\n        self.app =\
      \ Application.builder().token(token).build()\n        \n        # Single message\
      \ handler\n        self.app.add_handler(\n            MessageHandler(filters.TEXT,\
      \ self.handle_message)\n        )\n    \n    async def handle_message(self,\
      \ update, context):\n        # Simple logging to file\n        with open('interactions.log',\
      \ 'a') as f:\n            f.write(f\"{update.effective_user.id}: {update.message.text}\\\
      n\")\n        \n        # Basic response\n        await update.message.reply_text(\n\
      \            \"I received your message. Let me think about it...\"\n       \
      \ )\n```\n\n### 2. Add Simple Identity Tracking\n\n```python\n# simple_identity.py\n\
      import sqlite3\nfrom dataclasses import dataclass\n\n@dataclass\nclass Identity:\n\
      \    person_id: str\n    platform: str\n    platform_id: str\n\nclass SimpleIdentityStore:\n\
      \    def __init__(self):\n        self.conn = sqlite3.connect('identity.db')\n\
      \        self.conn.execute(\"\"\"\n            CREATE TABLE IF NOT EXISTS identities\
      \ (\n                person_id TEXT PRIMARY KEY,\n                platform TEXT,\n\
      \                platform_id TEXT,\n                UNIQUE(platform, platform_id)\n\
      \            )\n        \"\"\")\n    \n    def get_or_create_identity(self,\
      \ platform: str, platform_id: str) -> Identity:\n        cursor = self.conn.cursor()\n\
      \        \n        # Try to find existing\n        cursor.execute(\n       \
      \     \"SELECT person_id FROM identities WHERE platform = ? AND platform_id\
      \ = ?\",\n            (platform, platform_id)\n        )\n        result = cursor.fetchone()\n\
      \        \n        if result:\n            return Identity(result[0], platform,\
      \ platform_id)\n            \n        # Create new if not found\n        person_id\
      \ = f\"person_{platform}_{platform_id}\"\n        cursor.execute(\n        \
      \    \"INSERT INTO identities (person_id, platform, platform_id) VALUES (?,\
      \ ?, ?)\",\n            (person_id, platform, platform_id)\n        )\n    \
      \    self.conn.commit()\n        \n        return Identity(person_id, platform,\
      \ platform_id)\n```\n\n### 3. Add Basic Knowledge Storage\n\n```python\n# simple_knowledge.py\n\
      import json\nfrom pathlib import Path\n\nclass SimpleKnowledgeStore:\n    def\
      \ __init__(self):\n        self.knowledge_dir = Path('knowledge')\n        self.knowledge_dir.mkdir(exist_ok=True)\n\
      \    \n    def store_knowledge(self, content: str, metadata: dict):\n      \
      \  # Simple file-based storage\n        knowledge_id = len(list(self.knowledge_dir.glob('*.json')))\n\
      \        \n        knowledge_file = self.knowledge_dir / f\"{knowledge_id}.json\"\
      \n        knowledge_file.write_text(json.dumps({\n            'content': content,\n\
      \            'metadata': metadata\n        }))\n        \n        return knowledge_id\n\
      \    \n    def get_knowledge(self, knowledge_id: int) -> dict:\n        knowledge_file\
      \ = self.knowledge_dir / f\"{knowledge_id}.json\"\n        if knowledge_file.exists():\n\
      \            return json.loads(knowledge_file.read_text())\n        return None\n\
      ```\n\n### 4. Simple State Tracking\n\n```python\n# simple_state.py\nfrom typing\
      \ import Dict\nimport json\nfrom pathlib import Path\n\nclass SimpleStateManager:\n\
      \    def __init__(self):\n        self.state_file = Path('states.json')\n  \
      \      if not self.state_file.exists():\n            self.state_file.write_text('{}')\n\
      \    \n    def get_state(self, person_id: str) -> dict:\n        states = json.loads(self.state_file.read_text())\n\
      \        return states.get(person_id, {\n            'stage': 'new',\n     \
      \       'interactions': 0,\n            'last_topic': None\n        })\n   \
      \ \n    def update_state(self, person_id: str, updates: dict):\n        states\
      \ = json.loads(self.state_file.read_text())\n        current = states.get(person_id,\
      \ {})\n        current.update(updates)\n        states[person_id] = current\n\
      \        self.state_file.write_text(json.dumps(states))\n```\n\n### 5. Combine\
      \ into Simple Bot\n\n```python\n# main.py\nfrom simple_bot import SimpleBot\n\
      from simple_identity import SimpleIdentityStore\nfrom simple_knowledge import\
      \ SimpleKnowledgeStore\nfrom simple_state import SimpleStateManager\n\nclass\
      \ BecomingOneBot:\n    def __init__(self, token: str):\n        self.bot = SimpleBot(token)\n\
      \        self.identity_store = SimpleIdentityStore()\n        self.knowledge_store\
      \ = SimpleKnowledgeStore()\n        self.state_manager = SimpleStateManager()\n\
      \    \n    async def handle_message(self, update, context):\n        # Get or\
      \ create identity\n        identity = self.identity_store.get_or_create_identity(\n\
      \            platform='telegram',\n            platform_id=str(update.effective_user.id)\n\
      \        )\n        \n        # Get current state\n        state = self.state_manager.get_state(identity.person_id)\n\
      \        \n        # Store message as knowledge\n        knowledge_id = self.knowledge_store.store_knowledge(\n\
      \            content=update.message.text,\n            metadata={\n        \
      \        'person_id': identity.person_id,\n                'timestamp': update.message.date.isoformat()\n\
      \            }\n        )\n        \n        # Update state\n        self.state_manager.update_state(\n\
      \            person_id=identity.person_id,\n            updates={\n        \
      \        'interactions': state['interactions'] + 1,\n                'last_topic':\
      \ update.message.text[:50]\n            }\n        )\n        \n        # Simple\
      \ response\n        await update.message.reply_text(\n            f\"Message\
      \ received! This is interaction #{state['interactions'] + 1}\"\n        )\n\n\
      if __name__ == '__main__':\n    bot = BecomingOneBot('YOUR_TOKEN_HERE')\n  \
      \  bot.bot.app.run_polling()\n```\n\n### Key Principles:\n\n1. **Start Simple**\n\
      \   - File-based storage\n   - Single channel\n   - Basic functionality\n  \
      \ - No complex dependencies\n\n2. **Keep Components Separate**\n   - Identity\
      \ management\n   - Knowledge storage\n   - State tracking\n   - Message handling\n\
      \n3. **Easy to Understand**\n   - Clear file structure\n   - Simple functions\n\
      \   - Basic data types\n   - File-based persistence\n\n4. **Easy to Evolve**\n\
      \   - Replace components individually\n   - Add features gradually\n   - Test\
      \ in isolation\n   - Clear upgrade paths\n\n### Evolution Path:\n\n1. **Identity\
      \ Store** \u2192 PostgreSQL\n   ```python\n   # When ready, create proper database\n\
      \   class PostgresIdentityStore:\n       def __init__(self):\n           self.pool\
      \ = asyncpg.create_pool(\n               user='user',\n               password='password',\n\
      \               database='identity_db'\n           )\n   ```\n\n2. **Knowledge\
      \ Store** \u2192 Pinecone\n   ```python\n   # When vector search needed\n  \
      \ class PineconeKnowledgeStore:\n       def __init__(self):\n           self.pinecone\
      \ = pinecone.init(\n               api_key='your_key'\n           )\n   ```\n\
      \n3. **State Manager** \u2192 Redis\n   ```python\n   # When real-time state\
      \ needed\n   class RedisStateManager:\n       def __init__(self):\n        \
      \   self.redis = aioredis.from_url(\n               'redis://localhost'\n  \
      \         )\n   ```\n\n4. **Message Handler** \u2192 Advanced Pipeline\n   ```python\n\
      \   # When more sophistication needed\n   class AdvancedMessageHandler:\n  \
      \     def __init__(self):\n           self.preprocessors = []\n           self.analyzers\
      \ = []\n           self.responders = []\n   ```\n\n### Remember:\n\n1. **Start\
      \ with files** - Easy to debug and understand\n2. **One channel first** - Perfect\
      \ the flow before expanding\n3. **Simple schemas** - Add complexity when needed\n\
      4. **Clear interfaces** - Makes evolution easier\n5. **Local first** - Cloud\
      \ services when ready\n\nThis gives you a working system in hours, not weeks,\
      \ while maintaining a clear path to sophistication.\n"
    analysis: 'TOPICS: Bot Development, Python Programming, Telegram API, Identity
      Tracking

      TYPE: Technical Guide/Documentation

      CONCEPTS: Simple Bot Implementation, Message Handling, Logging, Identity Tracking,
      SQLite3 Database, Dataclasses

      RATIO: 80% Technical / 20% Conceptual

      DETAILS: The document provides Python code snippets for creating a simple bot
      using the Telegram API. It starts with a basic implementation that includes
      a single message handler and logging to a file. It then discusses adding identity
      tracking using SQLite3 and Python''s dataclasses. The bot''s main function is
      to receive messages and respond with a basic acknowledgment.'
    analyzed_at: '2025-08-19T11:18:46.356068'
  destination: Phase3_AgentExpansions/technical
size_bytes: 7647
